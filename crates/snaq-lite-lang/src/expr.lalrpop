//! Expression grammar: float literals, +, -, *, / (or "per"), parentheses, implicit multiplication, function calls.
//! Produces crate::ir::ExprDef.
//! Uses custom lexer so "ident (" is tokenized as FuncIdent; "sin(1)" is a call, "sin" alone is Ident.
//! NumIdents (number + one or more idents) and IdentIdents (one or more idents) form single factors
//! so "2 pi rad", "pi rad", and "1 s" parse correctly; PiIdents allows "π rad" like "pi rad".

use crate::ir::{CallArg, ExprDef};
use crate::lexer::Tok;

grammar;

extern {
    type Location = usize;
    type Error = crate::lexer::LexicalError;

    enum crate::lexer::Tok {
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Star,
        "/" => Tok::Slash,
        "per" => Tok::Per,
        "as" => Tok::As,
        "π" => Tok::Pi,
        "," => Tok::Comma,
        ":" => Tok::Colon,
        Num => Tok::Num(<ordered_float::OrderedFloat<f64>>),
        Ident => Tok::Ident(<String>),
        FuncIdent => Tok::FuncIdent(<String>),
    }
}

pub Expr: ExprDef = {
    <l:Expr> "+" <r:Term> => ExprDef::Add(Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:Term> => ExprDef::Sub(Box::new(l), Box::new(r)),
    <e:Expr> "as" <u:UnitTerm> => ExprDef::As(Box::new(e), Box::new(u)),
    Term,
};

// Unit-only expression (idents, *, /, per): e.g. "m", "meters per second", "newton per squareinch".
UnitTerm: ExprDef = {
    <l:UnitTerm> "*" <r:IdentIdents> => ExprDef::Mul(Box::new(l), Box::new(r)),
    <l:UnitTerm> "/" <r:IdentIdents> => ExprDef::Div(Box::new(l), Box::new(r)),
    <l:UnitTerm> "per" <r:IdentIdents> => ExprDef::Div(Box::new(l), Box::new(r)),
    IdentIdents,
};

ImplicitMulRight: ExprDef = {
    <n:Num> => ExprDef::LitScalar(n),
    "(" <e:Expr> ")" => e,
};

// Number followed by one or more idents: "1 s" or "2 pi rad" as a single factor (so "/ 1 s" divides by 1 s).
NumIdents: ExprDef = {
    <n:Num> <id:Ident> => ExprDef::Mul(
        Box::new(ExprDef::LitScalar(n)),
        Box::new(ExprDef::LitUnit(id)),
    ),
    <prev:NumIdents> <id:Ident> => ExprDef::Mul(Box::new(prev), Box::new(ExprDef::LitUnit(id))),
};

// One or more idents (no number): "pi" or "pi rad" as a single factor.
IdentIdents: ExprDef = {
    <id:Ident> => ExprDef::LitUnit(id),
    <prev:IdentIdents> <id:Ident> => ExprDef::Mul(Box::new(prev), Box::new(ExprDef::LitUnit(id))),
};

// One or more idents following "π" (so "π rad" and "π rad degree" work like "pi rad").
IdentsRest: ExprDef = {
    <id:Ident> => ExprDef::LitUnit(id),
    <prev:IdentsRest> <id:Ident> => ExprDef::Mul(Box::new(prev), Box::new(ExprDef::LitUnit(id))),
};

// "π" alone or "π" followed by one or more idents (e.g. "π rad").
PiIdents: ExprDef = {
    "π" => ExprDef::LitSymbol("pi".to_string()),
    "π" <id:Ident> => ExprDef::Mul(
        Box::new(ExprDef::LitSymbol("pi".to_string())),
        Box::new(ExprDef::LitUnit(id)),
    ),
    "π" <id:Ident> <rest:IdentsRest> => ExprDef::Mul(
        Box::new(ExprDef::Mul(
            Box::new(ExprDef::LitSymbol("pi".to_string())),
            Box::new(ExprDef::LitUnit(id)),
        )),
        Box::new(rest),
    ),
};

Term: ExprDef = {
    <l:Term> "*" <r:Factor> => ExprDef::Mul(Box::new(l), Box::new(r)),
    <l:Term> "/" <r:Factor> => ExprDef::Div(Box::new(l), Box::new(r)),
    <l:Term> "per" <r:Factor> => ExprDef::Div(Box::new(l), Box::new(r)),
    <l:Term> <r:ImplicitMulRight> => ExprDef::Mul(Box::new(l), Box::new(r)),
    Factor,
};

Factor: ExprDef = {
    "-" <e:Factor> => ExprDef::Neg(Box::new(e)),
    <ni:NumIdents> => ni,
    <n:Num> => ExprDef::LitScalar(n),
    <pi:PiIdents> => pi,
    <id:FuncIdent> "(" <args:ArgList> ")" => ExprDef::Call(id, args),
    <ii:IdentIdents> => ii,
    "(" <e:Expr> ")" => e,
};

// One argument: named (Ident : Expr) or positional (Expr). Named first so "a: 1" is not parsed as positional "a".
CallArg: CallArg = {
    <id:Ident> ":" <e:Expr> => CallArg::Named(id, Box::new(e)),
    <e:Expr> => CallArg::Positional(Box::new(e)),
};

// Left-recursive list to avoid reduce/shift conflict on ",".
ArgList: Vec<CallArg> = {
    <single:CallArg> => vec![single],
    <rest:ArgList> "," <last:CallArg> => {
        let mut rest = rest;
        rest.push(last);
        rest
    },
};
