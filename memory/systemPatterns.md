# System patterns

- **Parsing:** LALRPOP grammar in `crates/snaq-lite-lang/src/expr.lalrpop`; generated parser wired via `lalrpop_mod!(...)` in `parser.rs`. Build script `build.rs` runs `lalrpop::process_src()`. Float literals use conventional syntax; fallible actions (=>?) so invalid/overflow yields a parse error. Precedence: Expr (+, -) ← Term (*, /, per) ← Factor (unary minus, literal, parentheses). Unary minus at Factor level (e.g. `-1`, `-(2*3)`). Multiplication can be implicit only when the RHS is a number or parenthesized expression (e.g. `10 20` → 10*20, `2 (3+4)` → 14); `10 m` stays a single quantity literal (Ident excluded from implicit-mul RHS to avoid ambiguity). Division can be written as `/` or `per` (e.g. `3 kilometers per hour`).
- **IR:** `ExprDef` has parse-time variants `LitScalar`, `LitWithUnit`, `LitUnit`, `Neg(Box<ExprDef>)` and resolved `Lit(Quantity)`, `LitSymbol(String)`; binary `Add`, `Sub`, `Mul`, `Div`. Two-step flow: parse → resolve (with unit registry) → `ExprDef` with `Lit(Quantity)` or `LitSymbol` for literals (unknown idents → symbols). `ExprData` has `Lit(Quantity)`, `LitSymbol(String)`; `value()` returns `Result<Value, RunError>`.
- **Numbers and quantities:** Numeric values are `SnaqNumber` (value + variance). Variance propagates through arithmetic (Add/Sub: sum of variances; Mul/Div: standard propagation; scale by f64: variance × factor²). Literals get variance from f64 precision via `SnaqNumber::from_literal`. `Quantity` holds `number: SnaqNumber` and unit; `new(f64, unit)` / `from_scalar(f64)` use `from_literal`; results of arithmetic use `with_number(SnaqNumber, unit)`.
- **Units:** Default registry (`default_si_registry`) provides all 7 SI base units (m, kg, s, A, K, mol, cd) and all SI derived units with special names (J, C, V, F, ohm, S, Wb, T, H, Hz, N, Pa, W, lm, lx, Bq, Gy, Sv, kat), plus km, g, hour, minute, second, seconds, mile, au, parsec, light_year, joule, eV, celsius. Long-form aliases for base/derived units (ampere, kelvin, mole, candela, gram, volt, coulomb, etc.) via `add_derived_alias`. Prefix resolution via `get_unit_with_prefix` (e.g. km, mm). Quantity has `full_simplify` and `full_simplify_with_registry`.
- **Errors:** LALRPOP `ParseError` is mapped to `crate::error::ParseError` in the parser wrapper. Generated code has targeted `#[allow(...)]` for Clippy.
- **±∞:** Only +∞ and -∞ supported (no NaN). Division: nonzero/0 → ±∞, 0/0 → DivisionByZero. Infinite values have variance 0; display and arithmetic via f64. `Quantity::is_infinite()` / `is_finite()`; `convert_to` short-circuits when value is infinite (unit change only).
- **Symbols:** `SymbolRegistry` maps symbol names to `Option<f64>` (built-ins: pi, π, e). Unknown identifiers resolve to `LitSymbol`. Evaluation returns `Value` (Numeric or Symbolic). `SymbolicExpr` (Number, Symbol, Sum, Product, Neg, Div) with simplification; `SymbolicQuantity(expr, unit)`. Default: symbolic result; `run_numeric()` / `value.to_quantity(registry)` for substitution. CLI: default symbolic, `--numeric` for numeric. Error `SymbolHasNoValue(name)` when substituting and symbol has no value.
- **CAS:** `cas/` module: interned AST (`ExprId`, `ExprNode`, `ExprInterner`), canonicalization (flatten Add/Mul, sort by rank), rewrite (identity/annihilation, constant fold, like-term collection). `simplify_symbolic(def, registry)` and `simplify_numeric(def, unit_registry, symbol_registry)`; `substitute_symbols(def, symbol_registry)`. Run pipelines apply CAS before building Salsa program. Division by zero during rewrite returns `RunError::DivisionByZero`.
