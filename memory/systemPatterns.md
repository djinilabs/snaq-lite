# System patterns

- **Parsing:** Custom lexer in `lexer.rs` emits `FuncIdent(name)` when identifier is followed by `(`, else `Ident(name)`; disambiguates `sin(1)` (call) vs `sin` (symbol). LALRPOP grammar in `expr.lalrpop` uses extern tokens (Num, Ident, FuncIdent, etc.). Precedence: Expr (+, -) ← Term (*, /, per, implicit mul) ← Factor (unary minus, literal, `FuncIdent "(" ArgList ")"`, Ident, parentheses). Call args: `CallArg` = `Ident ":" Expr` (named) or `Expr` (positional); `ArgList` left-recursive.
- **IR:** `ExprDef` has parse-time variants `LitScalar`, `LitWithUnit`, `LitUnit`, `Neg(Box<ExprDef>)` and resolved `Lit(Quantity)`, `LitSymbol(String)`, `Call(String, Vec<CallArg>)`; binary `Add`, `Sub`, `Mul`, `Div`. `CallArg` = `Positional(Box<ExprDef>)` or `Named(String, Box<ExprDef>)`. Two-step flow: parse → resolve (with unit registry) → `ExprDef` with `Lit(Quantity)`, `LitSymbol`, or `Call` for literals. `ExprData` has `Call(name, Vec<(Option<String>, Expression)>)`; `value()` returns `Result<Value, RunError>`.
- **Numbers and quantities:** Numeric values are `SnaqNumber` (value + variance). Variance propagates through arithmetic (Add/Sub: sum of variances; Mul/Div: standard propagation; scale by f64: variance × factor²). Literals get variance from f64 precision via `SnaqNumber::from_literal`. `Quantity` holds `number: SnaqNumber` and unit; `new(f64, unit)` / `from_scalar(f64)` use `from_literal`; results of arithmetic use `with_number(SnaqNumber, unit)`.
- **Units:** Default registry (`default_si_registry`) provides all 7 SI base units (m, kg, s, A, K, mol, cd) and all SI derived units with special names (J, C, V, F, ohm, S, Wb, T, H, Hz, N, Pa, W, lm, lx, Bq, Gy, Sv, kat), plus km, g, hour, minute, second, seconds, mile, au, parsec, light_year, joule, eV, celsius, and Angle (rad base, degree = π/180 rad, degrees alias). Long-form aliases for base/derived units (ampere, kelvin, mole, candela, gram, volt, coulomb, etc.) via `add_derived_alias`. Prefix resolution via `get_unit_with_prefix` (e.g. km, mm). Quantity has `full_simplify` and `full_simplify_with_registry`.
- **Errors:** LALRPOP `ParseError` is mapped to `crate::error::ParseError` in the parser wrapper. Generated code has targeted `#[allow(...)]` for Clippy.
- **±∞:** Only +∞ and -∞ supported (no NaN). Division: nonzero/0 → ±∞, 0/0 → DivisionByZero. Infinite values have variance 0; display and arithmetic via f64. `Quantity::is_infinite()` / `is_finite()`; `convert_to` short-circuits when value is infinite (unit change only).
- **Symbols:** `SymbolRegistry` maps symbol names to `Option<f64>` (built-ins: pi, π, e). Unknown identifiers resolve to `LitSymbol`. Evaluation returns `Value` (Numeric or Symbolic). `SymbolicExpr` (Number, Symbol, Sum, Product, Neg, Div, Call) with simplification; `SymbolicQuantity(expr, unit)`. Default: symbolic result; `run_numeric()` / `value.to_quantity(registry)` for substitution. CLI: default symbolic, `--numeric` for numeric. Error `SymbolHasNoValue(name)` when substituting and symbol has no value.
- **Functions:** Built-ins in `functions.rs`: sin, cos, tan (one arg, Angle dimension: rad or degree; converted to radians internally); max, min (two args, same dimension). Each built-in declares param names; call-site args bound positionally then by name (named can override). Unknown function → `RunError::UnknownFunction`. Wrong dimension for trig → `RunError::ExpectedAngle { actual }` (message suggests adding rad if argument is dimensionless). Symbolic calls: if any arg is symbolic, result is `Value::Symbolic(SymbolicExpr::Call(name, args))`. Variance is propagated through trig via first-order propagation: Var(f(x)) ≈ (f'(x))² Var(x).
- **CAS:** `cas/` module: interned AST (`ExprId`, `ExprNode`, `ExprInterner`), canonicalization (flatten Add/Mul, sort by rank), rewrite (identity/annihilation, constant fold, like-term collection). `simplify_symbolic(def, registry)` and `simplify_numeric(def, unit_registry, symbol_registry)`; `substitute_symbols(def, symbol_registry)`. Run pipelines apply CAS before building Salsa program. Division by zero during rewrite returns `RunError::DivisionByZero`.
