//! Expression grammar: float literals, +, -, *, /, parentheses.
//! Produces crate::ir::ExprDef.
//! Float literals use conventional syntax; invalid/overflow yields a parse error.

use crate::ir::ExprDef;
use lalrpop_util::ParseError;
use ordered_float::OrderedFloat;
use std::str::FromStr;

grammar;

extern {
    type Error = String;
}

pub Expr: ExprDef = {
    <l:Expr> "+" <r:Term> => ExprDef::Add(Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:Term> => ExprDef::Sub(Box::new(l), Box::new(r)),
    Term,
};

Term: ExprDef = {
    <l:Term> "*" <r:Factor> => ExprDef::Mul(Box::new(l), Box::new(r)),
    <l:Term> "/" <r:Factor> => ExprDef::Div(Box::new(l), Box::new(r)),
    Factor,
};

Factor: ExprDef = {
    <n:Num> => ExprDef::Lit(n),
    "(" <e:Expr> ")" => e,
};

Num: OrderedFloat<f64> = {
    <s:r"([0-9]+\.?[0-9]*|[0-9]*\.[0-9]+)([eE][+-]?[0-9]+)?"> =>? f64::from_str(s)
        .map(OrderedFloat::from)
        .map_err(|_| ParseError::User {
            error: "invalid float literal or out of range".to_string(),
        }),
};
