//! Expression grammar: float literals, +, -, *, / (or "per"), parentheses, implicit multiplication.
//! Produces crate::ir::ExprDef.
//! Float literals use conventional syntax; invalid/overflow yields a parse error.

use crate::ir::ExprDef;
use lalrpop_util::ParseError;
use ordered_float::OrderedFloat;
use std::str::FromStr;

grammar;

extern {
    type Error = String;
}

pub Expr: ExprDef = {
    <l:Expr> "+" <r:Term> => ExprDef::Add(Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:Term> => ExprDef::Sub(Box::new(l), Box::new(r)),
    Term,
};

// Right-hand side of implicit multiplication only: number or parenthesized expr.
// Excludes Ident so that "10 m" stays one quantity literal (Num Ident), not 10 * m.
ImplicitMulRight: ExprDef = {
    <n:Num> => ExprDef::LitScalar(n),
    "(" <e:Expr> ")" => e,
};

Term: ExprDef = {
    <l:Term> "*" <r:Factor> => ExprDef::Mul(Box::new(l), Box::new(r)),
    <l:Term> "/" <r:Factor> => ExprDef::Div(Box::new(l), Box::new(r)),
    // "per" is division alias; LALRPOP gives string literals higher lexer priority than Ident, so "per" is not parsed as identifier
    <l:Term> "per" <r:Factor> => ExprDef::Div(Box::new(l), Box::new(r)),
    // Implicit multiplication: only when RHS is number or (expr), e.g. "10 20" → 10*20, "2 (3+4)" → 14
    <l:Term> <r:ImplicitMulRight> => ExprDef::Mul(Box::new(l), Box::new(r)),
    Factor,
};

Factor: ExprDef = {
    "-" <e:Factor> => ExprDef::Neg(Box::new(e)),
    <n:Num> <id:Ident> => ExprDef::LitWithUnit(n, id),
    <n:Num> => ExprDef::LitScalar(n),
    "π" => ExprDef::LitSymbol("pi".to_string()),
    <id:Ident> => ExprDef::LitUnit(id),
    "(" <e:Expr> ")" => e,
};

Ident: String = {
    <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string(),
};

Num: OrderedFloat<f64> = {
    <s:r"([0-9]+\.?[0-9]*|[0-9]*\.[0-9]+)([eE][+-]?[0-9]+)?"> =>? f64::from_str(s)
        .map(OrderedFloat::from)
        .map_err(|_| ParseError::User {
            error: "invalid float literal or out of range".to_string(),
        }),
};
