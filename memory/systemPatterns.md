# System patterns

- **Parsing:** Custom lexer in `lexer.rs` emits `FuncIdent(name)` when identifier is followed by `(`, else `Ident(name)`; disambiguates `sin(1)` (call) vs `sin` (symbol). Keywords: "per" (division), "as" (unit conversion; boundary check so "aspect" stays Ident). LALRPOP grammar in `expr.lalrpop` uses extern tokens (Num, Ident, FuncIdent, etc.). Precedence: Expr (+, -, as) ← Term (*, /, per, implicit mul) ← Factor (unary minus, NumIdents, literal, `FuncIdent "(" ArgList ")"`, Ident, parentheses). **UnitTerm:** unit-only expression (IdentIdents, *, /, per) for RHS of "as" (e.g. "m", "meters per second"). **NumIdents:** number followed by one or more idents is one factor (e.g. "1 s", "2 pi rad"); parses as left-associated Mul chain so " / 1 s" divides by 1 s and "2 pi rad" has pi→symbol, rad→unit at resolve. **IdentIdents:** one or more idents with no number (e.g. "pi", "pi rad") is one factor; "pi rad" parses as Mul(pi, rad), resolve attributes to symbol and unit. **PiIdents:** "π" alone or "π" + one or more idents (e.g. "π rad") so unicode π behaves like "pi rad". Implicit mul RHS is only number or parenthesized expr (not ident). Call args: `CallArg` = `Ident ":" Expr` (named) or `Expr` (positional); `ArgList` left-recursive.
- **IR:** `ExprDef` has parse-time variants `LitScalar`, `LitWithUnit`, `LitUnit`, `Neg(Box<ExprDef>)` and resolved `Lit(Quantity)`, `LitSymbol(String)`, `Call(String, Vec<CallArg>)`, `As(Box<ExprDef>, Box<ExprDef>)` (unit conversion: left value expr, right unit-only expr). Binary `Add`, `Sub`, `Mul`, `Div`. `CallArg` = `Positional(Box<ExprDef>)` or `Named(String, Box<ExprDef>)`. Two-step flow: parse → resolve (with unit registry) → `ExprDef` with `Lit(Quantity)`, `LitSymbol`, `Call`, or `As` for literals. RHS of `As` resolved via `resolve_unit_expr` (only LitUnit/Mul/Div → Lit(Quantity), no symbols). `ExprData` has `Call(name, Vec<(Option<String>, Expression)>)` and `As(Expression, Expression)`; `value()` returns `Result<Value, RunError>`.
- **Numbers and quantities:** Numeric values are `SnaqNumber` (value + variance). Variance propagates through arithmetic (Add/Sub: sum of variances; Mul/Div: standard propagation; scale by f64: variance × factor²). Literals get variance from f64 precision via `SnaqNumber::from_literal`. `Quantity` holds `number: SnaqNumber` and unit; `new(f64, unit)` / `from_scalar(f64)` use `from_literal`; results of arithmetic use `with_number(SnaqNumber, unit)`.
- **Units:** Default registry (`default_si_registry`) provides all 7 SI base units (m, kg, s, A, K, mol, cd) and all SI derived units with special names (J, C, V, F, ohm, S, Wb, T, H, Hz, N, Pa, W, lm, lx, Bq, Gy, Sv, kat), plus km, g, hour, minute, second, mile, au, parsec, light_year, joule, eV, celsius, and Angle (rad base, degree = π/180 rad). Registry stores singular forms; plural input (e.g. "meters", "seconds") is normalized to singular before lookup via the `singularize` crate. Long-form aliases (ampere, kelvin, mole, candela, gram, volt, coulomb, etc.) via `add_derived_alias`. Prefix resolution via `get_unit_with_prefix` (e.g. km, mm). Quantity has `full_simplify` and `full_simplify_with_registry`.
- **Errors:** LALRPOP `ParseError` is mapped to `crate::error::ParseError` in the parser wrapper. Generated code has targeted `#[allow(...)]` for Clippy.
- **±∞:** Only +∞ and -∞ supported (no NaN). Division: nonzero/0 → ±∞, 0/0 → DivisionByZero. Infinite values have variance 0; display and arithmetic via f64. `Quantity::is_infinite()` / `is_finite()`; `convert_to` short-circuits when value is infinite (unit change only).
- **Symbols:** `SymbolRegistry` maps symbol names to numeric values (built-ins: pi, π, e, sqrt_2, sqrt_3). Display: pi→π, sqrt_2→√2, sqrt_3→√3 in symbolic output. Unknown identifiers resolve to `LitSymbol`. Evaluation returns `Value` (Numeric or Symbolic). `SymbolicExpr` (Number, Symbol, Sum, Product, Neg, Div, Call) with simplification; `SymbolicQuantity(expr, unit)`. Default: symbolic result; `run_numeric()` / `value.to_quantity(registry)` for substitution. CLI: default symbolic, `--numeric` for numeric. Error `SymbolHasNoValue(name)` when substituting and symbol has no value.
- **Functions:** Built-ins in `functions.rs`: sin, cos, tan (one arg, Angle dimension: rad or degree; converted to radians internally); max, min (two args, same dimension). For well-known angles (0, π/6, π/4, π/3, π/2, π and degree 0°, 30°, 45°, 60°, 90°, 180°), trig returns symbolic exact results (e.g. √2/2, √3/2 via constants sqrt_2, sqrt_3). `KnownAngle`, `known_angle_from_rad`, `known_angle_from_symbolic`, `exact_sin/cos/tan`; eval_call uses them so symbolic run keeps constants (π, √2, √3) in display and run_numeric yields a number. Each built-in declares param names; call-site args bound positionally then by name. Unknown function → `RunError::UnknownFunction`. Wrong dimension for trig → `RunError::ExpectedAngle { actual }`. Symbolic calls: if any arg is symbolic and not a known angle, result is `Value::Symbolic(SymbolicExpr::Call(name, args))`. Variance is propagated through trig via first-order propagation.
- **CAS:** `cas/` module: interned AST (`ExprId`, `ExprNode`, `ExprInterner`), canonicalization (flatten Add/Mul, sort by rank), rewrite (identity/annihilation, constant fold, like-term collection). `simplify_symbolic(def, registry)` and `simplify_numeric(def, unit_registry, symbol_registry)`; `substitute_symbols(def, symbol_registry)`. Run pipelines apply CAS before building Salsa program. Division by zero during rewrite returns `RunError::DivisionByZero`.
