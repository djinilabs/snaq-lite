# Active context

## Just completed
- **Review and improve (singularization):** Refactored `get_unit_with_prefix`: extracted `try_lookup(ident, prefixes_by_len)` to avoid duplicated exact+prefix logic; doc states returned Unit always uses canonical (singular) key. README: built-in units sentence now mentions meter, second and that plural names (meters, seconds, kilometers) are accepted and normalized. Test: `run_per_alias_for_division` asserts compound unit with plural uses canonical singular (e.g. "kilometers" → "kilometer" in factors). All 172 tests and clippy pass.
- **Singularization for units:** Plural unit names (e.g. "meters", "seconds") now resolve by normalizing to singular before lookup. Added `singularize` crate; `UnitRegistry::get_unit_with_prefix` tries exact and prefix match, then singularize(ident) and retry. Removed all explicit plural registrations from `default_si_registry` (amperes, meters, seconds, grams, volts, etc.); registry stores singular forms only. Tests: `second_and_seconds_recognized_as_time_units` expect "second"; `run_long_form_units_kilometers` expects "kilometer"; new `plural_unit_input_resolves_to_canonical_singular`. systemPatterns and unit_registry doc updated. All 172 tests and clippy pass.
- **sin(180 * degrees) = 0 fix:** `sin(180 * degrees)` was returning ≈ -0.8 because `UnitRegistry::to_base_unit_representation` did not incorporate the defining unit's factor when resolving derived aliases (e.g. "degrees" → degree → π/180 rad). So 180 degrees converted to rad as 180 instead of π. Fix: in the Derived branch, multiply `result_factor` by `def_base_factor` so the chain degrees → degree → rad yields π/180. Tests: `resolve_180_times_degrees_as_unit`, `simplify_sin_180_times_degrees_arg_is_180_degree`, `run_sin_180_times_degrees_equals_zero`. All 169 tests and clippy pass.
- **Symbolic trig at well-known angles:** Named constants `sqrt_2`, `sqrt_3` in symbol registry (display √2, √3; numeric value for substitution). Trig sin/cos/tan at well-known angles (0, π/6, π/4, π/3, π/2, π and degree equivalents) return symbolic exact results (0, 1, √2/2, √3/2, 1/2, √3, 1/√3, -1). Numeric path (`run_numeric`, `to_quantity`) substitutes constants so result is a number; symbolic path keeps constants in display. `KnownAngle`, `known_angle_from_rad`, `known_angle_from_symbolic`, `exact_sin/cos/tan` in functions.rs; eval_call in queries uses them. Tests: run_sin_pi_fourth_symbolic_sqrt2_over_2, run_numeric_sin_pi_fourth_is_number, run_numeric_trig_result_is_number, run_symbolic_trig_well_known_angles; run_sin_pi_returns_numeric_zero updated to allow symbolic 0. All 163 tests and clippy pass.
- **Review and improve (angle/trig):** ExpectedAngle now shows "(dimensionless)" when argument is scalar (was empty); hint simplified to "e.g. sin(pi * rad)". Trig logic extracted to `eval_trig` helper (sin/cos/tan share one path). Doc: try_eval_symbolic_call example sin(pi * rad); unit_registry comment "SI base units (7) + rad (Angle)". Test: run_sin_90_degree_equals_one. All 157 tests and clippy pass.
- **Angle dimension and trig:** Angle dimension with rad (base) and degree (π/180 rad), degrees alias. Trig (sin, cos, tan) require argument of Angle dimension; `require_angle` converts to rad, then f64 sin/cos/tan. Wrong dimension → `RunError::ExpectedAngle { actual }`; if actual is dimensionless, message suggests adding rad (e.g. sin(pi * rad)). Tests: angle_rad_degree_same_dimension_and_convert, run_sin_180_degree_equals_zero, run_function_dimension_mismatch_errors (sin(1 m) and sin(pi) → ExpectedAngle; hint for dimensionless). README and systemPatterns updated. All 156 tests and clippy pass.
- **Trig variance propagation:** sin, cos, tan in `functions.rs` now propagate argument variance via first-order propagation Var(f(x)) ≈ (f'(x))² Var(x). Result built with `Quantity::with_number(SnaqNumber::new(value, variance), unit)`. Tan sets result variance to 0 when result is non-finite (e.g. near pole). Tests: `trig_sin_propagates_variance`, `trig_cos_propagates_variance`, `trig_tan_propagates_variance`, `trig_tan_near_pole_succeeds_and_variance_non_negative`. systemPatterns.md updated. All 154 tests and clippy pass.
- **Miniature CAS:** Four-phase CAS in `cas/`: (1) Interning (`ExprId`, `ExprNode`, `ExprInterner`) with ExprDef ↔ interned conversion; (2) Canonicalization (rank, flatten Add/Mul, sort by rank); (3) Term rewriting (identity/annihilation, constant fold with UnitRegistry, like-term collection; only scalar Lits as coefficients in monomials; division by zero in rewrite → RunError::DivisionByZero); (4) Evaluation: `simplify_symbolic(def, registry)` and `simplify_numeric(def, unit_registry, symbol_registry)`; `substitute_symbols(def, symbol_registry)`. `run_with_registry` uses CAS symbolic pipeline before program/value; `run_numeric_with_registry` uses substitute then CAS numeric pipeline. Tests: interning round-trip/dedup, canonicalize flatten/sort, rewrite identity/annihilation/constant fold/like terms, run_cas_symbolic_like_terms_2pi_plus_3pi, run_cas_numeric_2pi_plus_3pi. Division-by-zero in constant folding returns DivisionByZero (run_division_by_zero_nonzero_yields_infinity and run_arithmetic_with_infinity updated). All 134 tests and clippy pass.
- **Review and improve (symbols):** README updated for `run` → `Value`, `run_numeric`, `run_scalar`, symbols, and CLI `--numeric`. Symbolic substitution: division-by-zero during substitute now returns `RunError::DivisionByZero` (not `SymbolHasNoValue`). Doc: `SymbolRegistry` (symbols without value = not in map), `Value` (Display and `to_quantity`). Test: `run_numeric_symbolic_div_by_zero_returns_division_by_zero` for `(1+pi)/0`. All 118 tests and clippy pass.
- **Symbols:** Symbols (e.g. pi, π, e or any unknown identifier) are supported. Default evaluation returns `Value` (symbolic by default): `1 + π` → "1 + π", `3 + 2 + π + 1` → "6 + π". `SymbolRegistry` (built-ins pi/π, e), `SymbolicExpr`/`SymbolicQuantity` with simplification (Sum/Product), `Value::Numeric`|`Value::Symbolic`. IR: `LitSymbol`; resolve treats unknown idents as symbols; grammar has `"π"` → LitSymbol("pi"). `run()` returns `Result<Value, RunError>`; `run_numeric()` substitutes and returns `Quantity`; CLI `--numeric` for numeric output; WASM `evaluate_numeric()`.

## Just completed (earlier)
- **Unary minus:** Grammar and IR now support a leading minus (e.g. `-1`, `-(2*3)`). Added `ExprDef::Neg` and `ExprData::Neg`; Factor rule `"-" Factor => Neg`; resolve and value() handle Neg via `Quantity::neg`. Tests: `parse_unary_minus`, `eval_unary_minus`. All tests and clippy pass.

## Just completed (earlier)
- **Review and improve (SnaqNumber):** `SnaqNumber` now derives `Copy` (removes unnecessary clones in Quantity). Variance clamped to non-negative in Mul, Div, Mul<f64>, Div<f64> for float safety. Doc comments: propagation rules on `SnaqNumber`, `Quantity::value`/`variance` documented. Test `snaq_number_variance_always_non_negative` added. All 98 tests and clippy pass.
- **SnaqNumber migration:** Numeric values are now `SnaqNumber` (value + variance). Variance is propagated through Add/Sub/Mul/Div/Neg and scaling by f64; literal variance derived from f64 precision `(value * ε/2)²`. `Quantity` uses `number: SnaqNumber`; `Quantity::new(f64, unit)` / `from_scalar(f64)` build via `SnaqNumber::from_literal`; arithmetic uses `Quantity::with_number`. `SnaqNumber` re-exported from crate; `Quantity::value()` and `Quantity::variance()` accessors. All tests and clippy pass.

## Just completed (earlier)
- **Unit display fix:** Division units (e.g. `kilometers / hour`) now display as `kilometers/hour` instead of `kilometers/hour⁻¹`. In `Unit::fmt`, denominator factors use positive exponent for display (slash already means "per"). Test `unit_display_division_no_redundant_inverse` added. All tests and clippy pass.

## Just completed (earlier)
- **Phase 2 – Syntax and evaluation:** Grammar supports quantity literals (`Num`, `Num Ident`, `Ident`); parser produces `LitScalar`/`LitWithUnit`/`LitUnit`; two-step resolve converts to `Lit(Quantity)`. IR uses `ExprDef::Lit(Quantity)`; `value()` returns `Result<Quantity, RunError>`. `run()` returns `Result<Quantity, RunError>`; `run_scalar()` for dimensionless result. Errors: UnknownUnit, DimensionMismatch, DivisionByZero. CLI/WASM use `run()` and Display. All tests and clippy pass.
- **Phase 1 – Core model and SI:** Dimension, Unit, Quantity, prefix, unit/dimension registries; default_si_registry (m, s, kg, km, hour, minute).

## Just completed (Phase 3)
- **Phase 3 – Prefixes and simplification:** Prefix symbols in `prefix.rs`; `get_unit_with_prefix` in registry (longest-match prefix + base unit); Unit Display with prefix (e.g. km, µm) and ·/solidus/⁻¹; `Quantity::full_simplify` (dimensionless → scalar); `Quantity::full_simplify_with_registry` (prefer value in [0.1, 1000]).

## Just completed (Phase 4)
- **Phase 4 – Unit/dimension parity:** Extended default registry with Numbat-style units: Length (mile, au, parsec, light_year), Energy (joule, eV). Same names and conversion factors as Numbat for expressions like `1 mile`, `1 parsec`, `1 eV`, `100 km / hour`. More modules (time, imperial, cgs, etc.) can be added to the same built-in registry.

## Review and improve (done)
- **README:** Updated API to `run()` → `Quantity`, `run_scalar()`; added unit examples (100 km/hour, 1 mile, 1.5 km + 500 m).
- **Tests:** Added `run_division_by_zero_returns_err` (1/0, 3 m / 0 s) and `run_dimension_mismatch_returns_err` (1 m + 1 s).
- **API:** `run_with_registry(input, &UnitRegistry)` for custom registries; `run()` delegates to it. Exported `UnitRegistry`; added `Clone` to `UnitRegistry` and `DimensionRegistry`. Doc comments clarified (default units, when to use `run_scalar`).

## Just completed
- **SI units:** All BIPM SI base units (m, kg, s, A, K, mol, cd) and SI derived units with special names: J, C, V, F, ohm, S, Wb, T, H, Hz, N, Pa, W, lm, lx, Bq, Gy, Sv, kat; long forms (coulomb, volt, farad, ohm, siemens, weber, tesla, henry, lumen, lux, becquerel, gray, sievert, katal) and celsius. Removed these from unsupported list; tests and clippy pass.
- **Review and improve:** README updated with full SI unit list and examples (1 second, 1 volt). Unit registry refactored with `add_derived_alias` helper to reduce repetition; long-form base unit aliases added (ampere, amperes, kelvin, kelvins, mole, moles, candela, candelas, gram, grams). Test `long_form_base_unit_aliases` added. All tests and clippy pass.

## Just completed
- **Division alias "per":** Grammar accepts `per` as alias for `/` (e.g. `3 kilometers per hour`). LALRPOP string literal has higher lexer priority than Ident, so "per" is parsed as operator. Test `run_per_alias_for_division`; README and systemPatterns updated.
- **Review and improve (per):** Grammar comment on lexer priority for "per"; README example shows result (`3 km/hour`); `run()` doc mentions "per"; added `parse_per_same_as_div`, `parse_ident_containing_per_still_ident`, and `run_scalar("6 per 2")` in `eval_div`. All tests and clippy pass.

## Just completed
- **Implicit multiplication:** Grammar uses `ImplicitMulRight` (Num or `"(" Expr ")"`) so only number or parenthesized expr can be RHS of implicit mul (e.g. `10 20` → 200, `2 (3 + 4)` → 14, `10 m 2` → 20 m). `10 m` stays one quantity literal; no Term-Ident implicit mul. Tests: `parse_implicit_mul`, `eval_implicit_mul`, `eval_implicit_mul_with_units`. Test `parse_invalid_float_is_error` renamed to `parse_1_2_3_as_implicit_mul` (e.g. `1.2.3` now parses as 1.2 * .3 = 0.36). systemPatterns updated.

## Review and improve (implicit multiplication)
- **Docs:** systemPatterns.md now states implicit mul only when RHS is number or (expr); README Language + Examples mention implicit mul with `10 20`, `2 (3+4)`; `run()` doc in lib.rs updated.
- **Tests:** `parse_quantity_literal` asserts "10 m" is LitWithUnit (not Mul); `eval_implicit_mul` adds "10 20 + 5" == 205 (precedence); `parse_implicit_mul_rhs_not_ident` documents that "2 3 m" is parse error (RHS of implicit mul cannot be Ident). All tests and clippy pass.

## Just completed
- **Review and improve (division by zero / ±∞):** Added `Quantity::is_infinite()` and `Quantity::is_finite()`; `convert_to` short-circuits when value is infinite (same dimension, unit change only). `Quantity::div` uses `is_sign_positive()` for ±∞. `QuantityError::DivisionByZero` documented as 0/0 (indeterminate). Test `quantity_convert_to_preserves_infinity`; div tests assert `is_infinite()`/`is_finite()`. README: division-by-zero note and example (`1/0` → `inf`). All tests and clippy pass.
- **Division by zero and ±infinity (no NaN):** Nonzero/0 → ±∞ (sign of numerator); 0/0 → DivisionByZero. SnaqNumber::from_literal sets variance 0 for infinite x. Quantity::div branches: 0/0 Err, nonzero/0 Ok(±∞). Tests: run_division_by_zero_nonzero_yields_infinity, run_zero_over_zero_returns_err, run_arithmetic_with_infinity; quantity and SnaqNumber tests for inf and div-by-zero.

## Just completed
- **Review and improve (function calling):** README documents function calls and built-ins (sin, cos, tan, max, min), with examples `sin(pi)`, `max(3, 2)`, `max(a: 1, b: 2)`. Suppressed generated-parser unused_imports warning via `#[allow(unused_imports)]` on lalrpop_mod!(expr). Tests: `run_sin_pi_returns_numeric_zero` (run("sin(pi)") → Numeric 0), `run_function_wrong_arity_errors` (sin(1,2), max(1)), `run_function_dimension_mismatch_errors` (sin(1 m), max(1 m, 2 s)). Doc for `try_eval_symbolic_call` in functions.rs. All 148 tests and clippy pass (no warnings).
- **Function calling:** Custom lexer emits `FuncIdent` when identifier is followed by `(`, so `sin(1)` parses as call. Grammar: `FuncIdent "(" ArgList ")"`, `CallArg` = named (`Ident ":" Expr`) or positional (`Expr`). IR: `ExprDef::Call(name, Vec<CallArg>)`, `ExprData::Call(name, Vec<(Option<String>, Expression)>)`. Resolve and CAS (interner, convert, canonical, rewrite) handle Call; substitute recurses into call args. `functions.rs`: built-ins sin, cos, tan (one dimensionless arg), max, min (two same-dimension args); param names for binding. Queries: `eval_call` binds positional then named args, evaluates; symbolic result when any arg symbolic. `SymbolicExpr::Call` for display. Errors: `UnknownFunction`. Tests: parse sin/max/named, eval sin(0), max/min, run_numeric sin(pi), run_symbolic sin(x), unknown function.

## Next steps
- Optional: add more unit modules (time: week, year; imperial: foot, pound; etc.) or .nbt loader for full Numbat module set.
- Optional: variance in symbolic form; user-defined symbols (let x = 2); more built-in constants (φ, c).
