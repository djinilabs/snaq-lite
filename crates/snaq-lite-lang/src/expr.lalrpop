//! Expression grammar: float literals, +, -, *, / (or "per"), parentheses, implicit multiplication, function calls.
//! Produces crate::ir::ExprDef.
//! Uses custom lexer so "ident (" is tokenized as FuncIdent; "sin(1)" is a call, "sin" alone is Ident.

use crate::ir::{CallArg, ExprDef};
use crate::lexer::Tok;

grammar;

extern {
    type Location = usize;
    type Error = crate::lexer::LexicalError;

    enum crate::lexer::Tok {
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Star,
        "/" => Tok::Slash,
        "per" => Tok::Per,
        "π" => Tok::Pi,
        "," => Tok::Comma,
        ":" => Tok::Colon,
        Num => Tok::Num(<ordered_float::OrderedFloat<f64>>),
        Ident => Tok::Ident(<String>),
        FuncIdent => Tok::FuncIdent(<String>),
    }
}

pub Expr: ExprDef = {
    <l:Expr> "+" <r:Term> => ExprDef::Add(Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:Term> => ExprDef::Sub(Box::new(l), Box::new(r)),
    Term,
};

ImplicitMulRight: ExprDef = {
    <n:Num> => ExprDef::LitScalar(n),
    "(" <e:Expr> ")" => e,
};

Term: ExprDef = {
    <l:Term> "*" <r:Factor> => ExprDef::Mul(Box::new(l), Box::new(r)),
    <l:Term> "/" <r:Factor> => ExprDef::Div(Box::new(l), Box::new(r)),
    <l:Term> "per" <r:Factor> => ExprDef::Div(Box::new(l), Box::new(r)),
    <l:Term> <r:ImplicitMulRight> => ExprDef::Mul(Box::new(l), Box::new(r)),
    Factor,
};

Factor: ExprDef = {
    "-" <e:Factor> => ExprDef::Neg(Box::new(e)),
    <n:Num> <id:Ident> => ExprDef::LitWithUnit(n, id),
    <n:Num> => ExprDef::LitScalar(n),
    "π" => ExprDef::LitSymbol("pi".to_string()),
    <id:FuncIdent> "(" <args:ArgList> ")" => ExprDef::Call(id, args),
    <id:Ident> => ExprDef::LitUnit(id),
    "(" <e:Expr> ")" => e,
};

// One argument: named (Ident : Expr) or positional (Expr). Named first so "a: 1" is not parsed as positional "a".
CallArg: CallArg = {
    <id:Ident> ":" <e:Expr> => CallArg::Named(id, Box::new(e)),
    <e:Expr> => CallArg::Positional(Box::new(e)),
};

// Left-recursive list to avoid reduce/shift conflict on ",".
ArgList: Vec<CallArg> = {
    <single:CallArg> => vec![single],
    <rest:ArgList> "," <last:CallArg> => {
        let mut rest = rest;
        rest.push(last);
        rest
    },
};
