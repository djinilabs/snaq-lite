//! Expression grammar: float literals, +, -, *, / (or "per"), parentheses.
//! Produces crate::ir::ExprDef.
//! Float literals use conventional syntax; invalid/overflow yields a parse error.

use crate::ir::ExprDef;
use lalrpop_util::ParseError;
use ordered_float::OrderedFloat;
use std::str::FromStr;

grammar;

extern {
    type Error = String;
}

pub Expr: ExprDef = {
    <l:Expr> "+" <r:Term> => ExprDef::Add(Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:Term> => ExprDef::Sub(Box::new(l), Box::new(r)),
    Term,
};

Term: ExprDef = {
    <l:Term> "*" <r:Factor> => ExprDef::Mul(Box::new(l), Box::new(r)),
    <l:Term> "/" <r:Factor> => ExprDef::Div(Box::new(l), Box::new(r)),
    // "per" is division alias; LALRPOP gives string literals higher lexer priority than Ident, so "per" is not parsed as identifier
    <l:Term> "per" <r:Factor> => ExprDef::Div(Box::new(l), Box::new(r)),
    Factor,
};

Factor: ExprDef = {
    <n:Num> <id:Ident> => ExprDef::LitWithUnit(n, id),
    <n:Num> => ExprDef::LitScalar(n),
    <id:Ident> => ExprDef::LitUnit(id),
    "(" <e:Expr> ")" => e,
};

Ident: String = {
    <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string(),
};

Num: OrderedFloat<f64> = {
    <s:r"([0-9]+\.?[0-9]*|[0-9]*\.[0-9]+)([eE][+-]?[0-9]+)?"> =>? f64::from_str(s)
        .map(OrderedFloat::from)
        .map_err(|_| ParseError::User {
            error: "invalid float literal or out of range".to_string(),
        }),
};
